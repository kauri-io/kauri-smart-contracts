pragma solidity 0.5.6;

import './GroupLogic.sol';
import './GroupI.sol';

/**
 * @title Kauri GroupConnector Smart Contract
 * @author kauri@consensys.net
 * @dev functions are generally separated by meta-tx and direct-tx
 */

contract GroupConnector is GroupI, GroupLogic
{

    //////////////////////////////////////////////////
    // CREATE_GROUP
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareCreateGroup
     *  @dev view function to prepare meta-tx for group creation
     *  @param _metadataLocator an IPFS hash
     *  @param _secretHashes array of max 10 add'l invite hashes
     *  @param _assignedRoles array of max 10 add'l roles of assigned invites
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by tx sender
     */

    function prepareCreateGroup(
        bytes32 _metadataLocator,
        bytes32[] calldata _secretHashes,
        uint8[] calldata _assignedRoles,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                address(this),
                "createGroup",
                _metadataLocator,
                _secretHashes,
                _assignedRoles,
                _nonce
            )
        );
    }

    /**
     *  [META-TX] createGroup
     *  @dev transaction function creating group with relayer acting as middle-man
     *  @dev tx sender is recovered from signature of prepareCreateGroup result
     *  @param _metadataLocator an IPFS hash
     *  @param _secretHashes array of max 10 add'l invite hashes
     *  @param _assignedRoles array of max 10 add'l roles of assigned invites
     *  @param _signature signature of signed msg hash from prepareCreateGroup
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful tx
     */

    function createGroup(
        bytes32 _metadataLocator,
        bytes32[] calldata _secretHashes,
        uint8[] calldata _assignedRoles,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareCreateGroup(
                _metadataLocator,
                _secretHashes,
                _assignedRoles,
                _nonce
            ),
            _signature,
            _nonce
        );

        createGroup(signer, _metadataLocator, _secretHashes, _assignedRoles);
    }

    /**
     *  [DIRECT-TX] createGroup
     *  @dev transaction function to directly create group without middle-man
     *  @dev sets msg.sender as groupOwner and admin
     *  @param _metadataLocator an IPFS hash
     *  @param _secretHashes array of max 10 add'l invite hashes
     *  @param _assignedRoles array of max 10 add'l roles of assigned invites
     *  @return bool upon successful tx
     */

    function createGroup(
        bytes32 _metadataLocator,
        bytes32[] calldata _secretHashes,
        uint8[] calldata _assignedRoles
    )
        external
        returns (bool)
    {
        createGroup(msg.sender, _metadataLocator, _secretHashes, _assignedRoles);
    }

    //////////////////////////////////////////////////
    // INVITATION
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareInvitation
     *  @dev view function to prepare storage of invitation 
     *  @dev tx sender address recovered using ecrecover
     *  @param _groupId group id to prepare invitation for
     *  @param _role role of the user to be invited
     *  @param _secretHash hash generated by backend
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by tx sender
     */

    function prepareInvitation(
        uint256 _groupId,
        uint8 _role,
        bytes32 _secretHash,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                address(this),
                "prepareInvitation",
                _groupId,
                _role,
                _secretHash,
                _nonce
            )
        );
    }

    /**
     *  [META-TX] storeInvitation
     *  @dev transaction function to store an invitation 
     *  @dev sender address recovered using ecrecover
     *  @param _groupId group id to prepare invitation for
     *  @param _role role of the user to be invited
     *  @param _secretHash hash generated by backend
     *  @param _signature signature of private key signing _secretHash
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful transaction
     */

    function storeInvitation(
        uint256 _groupId,
        uint8 _role,
        bytes32 _secretHash,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareInvitation(
                _groupId,
                _role,
                _secretHash,
                _nonce
            ),
            _signature,
            _nonce
        );

        storeInvitation(signer, _groupId, _role, _secretHash);
    }

    /**
     *  [DIRECT-TX] storeInvitation
     *  @dev transaction function to directly store an invitation 
     *  @dev sets msg.sender as caller, no middleman or meta-tx proxy
     *  @dev data store in key/value external storage contract
     *  @param _groupId group id to prepare invitation for
     *  @param _role role of the user to be invited
     *  @param _secretHash hash generated by backend
     *  @return bool upon successful transaction
     */

    function storeInvitation(
        uint256 _groupId,
        uint8 _role,
        bytes32 _secretHash
    )
        external
        returns (bool)
    {
        storeInvitation(msg.sender, _groupId, _role, _secretHash);
    }

    //////////////////////////////////////////////////
    // REVOKE_INVITATION
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareRevokeInvitation
     *  @dev transaction function to store an invitation 
     *  @dev data store in key/value external storage contract
     *  @param _groupId group id to prepare invitation for
     *  @param _secretHash hash generated by backend
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by tx sender
     */

    function prepareRevokeInvitation(
        uint256 _groupId,
        bytes32 _secretHash,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        // generate unique method call message
        return keccak256(
            abi.encodePacked(
                address(this),
                "revokeInvitation",
                _groupId,
                _secretHash,
                _nonce
            )
        );
    }

    /**
     *  [META-TX] revokeInvitation
     *  @dev transaction function to revoke an invitation
     *  @dev transaction sender acts as middle-man via meta-tx relayer
     *  @dev returned hash is signed and sent to meta-tx relayer 
     *  @dev the resulting signature is used to recover signer
     *  @param _groupId group id to prepare invitation for
     *  @param _secretHash hash generated by backend
     *  @param _nonce incrementable nonce used to prevent replay attacks
     */

    function revokeInvitation(
        uint256 _groupId,
        bytes32 _secretHash,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareRevokeInvitation(
                _groupId,
                _secretHash,
                _nonce
            ),
            _signature,
            _nonce
        );

        // call the logic
        revokeInvitation(signer, _groupId, _secretHash);
    }

    /**
     *  [DIRECT-TX] revokeInvitation
     *  @dev transaction function to directly revoke an invitation
     *  @dev transaction is submitted directly by msg.sender; not a meta-tx
     *  @param _groupId group id the invitation belongs to
     *  @param _secretHash hash generated by backend
     *  @return bool upon successful transaction
     */

    function revokeInvitation(
        uint256 _groupId,
        bytes32 _secretHash
    )
        external
        returns (bool)
    {
        revokeInvitation(msg.sender, _groupId, _secretHash);
    }

    //////////////////////////////////////////////////
    // ACCEPT_INVITATION
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareAcceptInvitationCommit
     *  @dev view function to prepare commit for accept invitation
     *  @dev prepare the commit of a commit/reveal scheme
     *  @param _groupId group id to prepare invitation for
     *  @param _addressSecretHash hash of (secret + sender address) 
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by sender
     */

    function prepareAcceptInvitationCommit(
        uint256 _groupId,
        bytes32 _addressSecretHash,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                _groupId,
                "acceptInvitationCommit",
                _addressSecretHash,
                _nonce
            )
        );
    }

    /**
     *  [META-TX] acceptInvitationCommit
     *  @dev transaction function for accepting an invitation commit
     *  @dev submit transaction for commit of commit/reveal scheme
     *  @param _groupId group id to prepare invitation for
     *  @param _addressSecretHash hash of (secret + sender address) 
     *  @param _signature signature of private key signing _secretHash
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful transaction
     */

    function acceptInvitationCommit(
        uint256 _groupId,
        bytes32 _addressSecretHash,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareAcceptInvitationCommit(
                _groupId,
                _addressSecretHash,
                _nonce
            ),
            _signature,
            _nonce
        );

        acceptInvitationCommit(signer, _groupId, _addressSecretHash);
    }

    /**
     *  [DIRECT-TX] acceptInvitationCommit
     *  @dev transaction function for directly making commit for accepting invitation
     *  @dev uses msg.sender within business logic; not a meta-tx
     *  @param _groupId group id where commit will be stored 
     *  @param _addressSecretHash keccak256 hash of (secret + sender address) 
     *  @return bool upon successful transaction
     */

    function acceptInvitationCommit(
        uint256 _groupId,
        bytes32 _addressSecretHash
    )
        external
        returns (bool)
    {
        acceptInvitationCommit(msg.sender, _groupId, _addressSecretHash);
    }

    /**
     *  [DIRECT-TX] acceptInvitation
     *  @dev transaction function for directly accepting an invitation
     *  @param _groupId group id to prepare invitation for
     *  @param _secret secret generated by backend
     *  @return bool upon successful transaction
     */

    function acceptInvitation(
        uint256 _groupId,
        bytes32 _secret,
        address _account
    )
        external
        returns (bool)
    {
        acceptInvitationLogic(_account, _groupId, _secret);
    }

    //////////////////////////////////////////////////
    // REMOVE_MEMBER
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareRemoveMember
     *  @dev view function to prepare removal of member
     *  @dev in the commit of a commit/reveal scheme
     *  @param _groupId group id where member belongs
     *  @param _accountToRemove account to be removed 
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by sender
     */

    function prepareRemoveMember(
        uint256 _groupId,
        address _accountToRemove,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                _groupId,
                "removeMember",
                _accountToRemove,
                _nonce
            )
        );
    }

    /**
     *  [META-TX] removeMember
     *  @dev transaction function to remove member from group
     *  @dev sender address recovered using ecrecover
     *  @param _groupId group id to remove member from
     *  @param _accountToRemove account to be removed 
     *  @param _signature sender's signature
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful transaction 
     */

    function removeMember(
        uint256 _groupId,
        address _accountToRemove,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareRemoveMember(
                _groupId,
                _accountToRemove,
                _nonce
            ),
            _signature,
            _nonce
        );

        removeMember(signer, _groupId, _accountToRemove);
    }

    /**
     *  [DIRECT-TX] removeMember
     *  @dev transaction function to directly remove member from group
     *  @dev uses msg.sender as sender; no meta-tx
     *  @param _groupId group id to remove member from
     *  @param _accountToRemove account to be removed from group
     *  @return bool upon successful tx
     */

    function removeMember(
        uint256 _groupId,
        address _accountToRemove
    )
        external
        returns (bool)
    {
        removeMember(msg.sender, _groupId, _accountToRemove);
    }

    //////////////////////////////////////////////////
    // LEAVE_GROUP
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareLeaveGroup
     *  @dev view function to prepare to leave group
     *  @param _groupId group id where member belongs
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 hash to be signed by sender
     */

    function prepareLeaveGroup(
        uint256 _groupId,
        uint256 _nonce
    )
        external
        view 
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                _groupId,
                "prepareLeaveGroup",
                _nonce
            )
        );
    }

    /**
     *  [META-TX] leaveGroup
     *  @dev transaction function to directly remove self from group
     *  @dev uses msg.sender as sender; no meta-tx
     *  @param _groupId group id to remove member from
     *  @param _signature sender's signature
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful tx
     */

    function leaveGroup(
        uint256 _groupId,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareLeaveGroup(
                _groupId,
                _nonce
            ),
            _signature,
            _nonce
        );

        removeMember(signer, _groupId, signer);
    }

    /**
     *  [DIRECT-TX] leaveGroup 
     *  @dev transaction function to directly remove self from group
     *  @dev uses msg.sender as sender; no meta-tx
     *  @param _groupId group id to remove member from
     *  @return bool upon successful tx
     */

    function leaveGroup(
        uint256 _groupId
    )
        external
        returns (bool)
    {
        removeMember(msg.sender, _groupId, msg.sender);
    }

    //////////////////////////////////////////////////
    // CHANGE_MEMBER
    //////////////////////////////////////////////////

    /**
     *  [META-TX PREPARE] prepareChangeMemberRole
     *  @dev view function to change member role of a group
     *  @param _groupId group id member belongs to
     *  @param _accountToChange account being changed 
     *  @param _newRole new role for the member
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bytes32 prepared hash to be signed by sender
     */

    function prepareChangeMemberRole(
        uint256 _groupId,
        address _accountToChange,
        uint8 _newRole,
        uint256 _nonce
    )
        external
        view
        returns (bytes32)
    {
        return keccak256(
            abi.encodePacked(
                _groupId,
                "changeMemberRole",
                _accountToChange,
                _newRole, // changed from _role to _newRole
                _nonce
            )
        );
    }

    /**
     *  [META-TX] changeMemberRole
     *  @dev transaction function to change member role of a group
     *  @param _groupId group id member belongs to
     *  @param _accountToChange account being changed 
     *  @param _newRole new role for the member
     *  @param _signature sender's signature
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return bool upon successful transaction
     */

    function changeMemberRole(
        uint256 _groupId,
        address _accountToChange,
        uint8 _newRole,
        bytes calldata _signature,
        uint256 _nonce
    )
        external
        returns (bool)
    {
        address signer = getSigner(
            this.prepareChangeMemberRole(
                _groupId,
                _accountToChange,
                _newRole,
                _nonce
            ),
            _signature,
            _nonce
        );

        changeMemberRole(signer, _groupId, _accountToChange, _newRole);
    }

    /**
     *  [DIRECT-TX] changeMemberRole
     *  @dev transaction function to directly change member role of a group
     *  @dev msg.sender used as sender; not a meta-tx
     *  @param _groupId group id member belongs to
     *  @param _accountToChange account to be changec 
     *  @param _newRole new role for the member
     *  @return bool upon successful transaction
     */

    function changeMemberRole(
        uint256 _groupId,
        address _accountToChange,
        uint8 _newRole
    )
        external
        returns (bool)
    {
        changeMemberRole(msg.sender, _groupId, _accountToChange, _newRole);
    }

    //////////////////////////////////////////////////
    // GET_NONCE
    //////////////////////////////////////////////////

    /**
     *  GET NONCE
     *  @dev get incrementable nonce of address passed to function
     *  @param _sender address to retrieve nonce from
     *  @return uint256 nonce of address
     */

    function getNonce(
        address _sender
    )
        public
        view
        returns (uint256)
    {
        return storageContract.getUintValue(
            keccak256(
                abi.encodePacked(
                    "nonces",
                    _sender
                )
            )
        );
    }

    ///////////////////////////////////////////////////////////////////////
    // UTILS
    ///////////////////////////////////////////////////////////////////////

    /**
     *  GET SIGNER
     *  @dev retrieve signer of a msg using signature and nonce
     *  @param _msg to recover (usually built with a prepare view function)
     *  @param _signature signature of transaction sender
     *  @param _nonce incrementable nonce used to prevent replay attacks
     *  @return address address of signer
     */

    function getSigner(
        bytes32 _msg,
        bytes memory _signature,
        uint256 _nonce
    )
        internal
        returns (address)
    {
        address signer = recoverSignature(_msg, _signature);

        uint256 nonce = getNonce(signer);

        require(signer != address(0), "unable to recover signature");
        require(_nonce == nonce, "using incorrect nonce");

        // increment signature nonce of signer by 1
        storageContract.incrementUintValue(
            keccak256(abi.encodePacked("nonces", signer)),
            1
        );

        return signer;
    }

    /**
     *  RECOVER SIGNATURE
     *  @dev splits signature into r,s,v vars and uses ecrecover on hash and signature
     *  @param _hash hash to use in ecrecover function
     *  @param _signature signature of transaction sender
     *  @return address address of signer
     */

    function recoverSignature(
        bytes32 _hash,
        bytes memory _signature
    )
        internal
        pure
        returns (address)
    {
        bytes32 r;
        bytes32 s;
        uint8 v;

        if (_signature.length != 65) {
            return address(0);
        }

        assembly {
            r := mload(add(_signature, 0x20))
            s := mload(add(_signature, 0x40))
            v := byte(0, mload(add(_signature, 0x60)))
        }

        if (v < 27) {
            v += 27;

        }

        address signer = ecrecover(
            prefixed(_hash),
            v,
            r,
            s
        );
        return signer;
    }

    /**
     *  PREFIX MESSAGE
     *  @dev prefix message with Ethereum Signed Message prefix
     *  @dev below message is prefixed when using JSON RPC eth.sign call
     *  @param _hash hash to add the prefix to
     *  @return bytes32 prefixed hash for recovery purposes
     */

    function prefixed(
        bytes32 _hash
    )
        internal
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash));
    }

}
